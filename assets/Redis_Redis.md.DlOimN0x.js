import{_ as t,c as d,o as s,af as r}from"./chunks/framework.B1UcUiOW.js";const p=JSON.parse('{"title":"一、Redis的数据类型","description":"","frontmatter":{},"headers":[],"relativePath":"Redis/Redis.md","filePath":"Redis/Redis.md"}'),i={name:"Redis/Redis.md"};function o(a,e,n,l,c,h){return s(),d("div",null,[...e[0]||(e[0]=[r('<h1 id="一、redis的数据类型" tabindex="-1">一、Redis的数据类型 <a class="header-anchor" href="#一、redis的数据类型" aria-label="Permalink to “一、Redis的数据类型”">​</a></h1><p>Redis 作为一款高性能的 <em><strong>*内存数据库*</strong></em>，提供了丰富的数据类型来满足不同业务场景需求，其中最核心、最常用的 5 种基础类型分别是：<em><strong>*String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Sorted Set（有序集合）*</strong></em>。这 5 种类型均基于 <em><strong>*键值对（Key-Value）*</strong></em> 结构，且支持灵活的操作命令。</p><h1 id="二、redis的集群部署" tabindex="-1">二、Redis的集群部署 <a class="header-anchor" href="#二、redis的集群部署" aria-label="Permalink to “二、Redis的集群部署”">​</a></h1><p>Redis 集群通常由多个节点组成，至少需要 3 个主节点，每个主节点可以有一个或多个从节点。这种结构提供了数据分片、高可用和负载均衡的能力。</p><h1 id="三、redis的缓存失效时间" tabindex="-1">三、Redis的缓存失效时间 <a class="header-anchor" href="#三、redis的缓存失效时间" aria-label="Permalink to “三、Redis的缓存失效时间”">​</a></h1><p><strong>1. 设置方法：</strong></p><ul><li><strong><code>EXPIRE key seconds</code></strong>：为已存在的 key 设置秒级过期时间。</li><li><strong><code>SET key value EX seconds</code></strong>：（推荐）在设置值的同时指定秒级过期时间，这是一个原子操作。</li><li>类似命令还有 <code>PEXPIRE</code>（毫秒）、<code>EXPIREAT</code>（到期时间戳）。</li></ul><p><strong>2. 工作原理：</strong></p><ul><li><strong>惰性删除</strong>：当客户端访问一个 key 时，才检查它是否过期。如果过期，则立即删除并返回空。</li><li><strong>定期删除</strong>：Redis 会每隔一段时间（默认每秒10次）随机抽查一些设置了过期时间的 key，并删除其中已过期的。</li></ul><p><strong>3. 关键特性：</strong></p><ul><li>过期时间到期后，key 会被自动从数据库中删除。</li><li>使用 <strong><code>TTL key</code></strong> 命令可以查询 key 的剩余生存时间（秒）。</li><li>重新用 <code>SET</code> 命令为 key 赋值会<strong>清除</strong>其原有的过期时间（除非使用 Redis 6.0+ 的 <code>KEEPTTL</code> 选项）。</li></ul><h3 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to “最佳实践”">​</a></h3><p><strong>永远为你不知道何时会失效的缓存设置一个过期时间</strong>，这是防止内存无限增长的最重要规则。根据数据更新频率，选择一个合理的时长（例如，会话数据 30 分钟，基础数据 24 小时）</p><h1 id="四、redis的缓存穿透、缓存击穿、缓存雪崩" tabindex="-1">四、Redis的缓存穿透、缓存击穿、缓存雪崩 <a class="header-anchor" href="#四、redis的缓存穿透、缓存击穿、缓存雪崩" aria-label="Permalink to “四、Redis的缓存穿透、缓存击穿、缓存雪崩”">​</a></h1><p>缓存穿透是指 客户端请求的 key 在缓存（Redis）和数据库中都不存在，导致请求 “穿透” 缓存，直接频繁访问数据库。</p><p>缓存击穿是指 一个热点 key在缓存中过期的瞬间，恰好有大量请求同时访问该 key，导致所有请求都穿透到数据库，瞬间压垮数据库。</p><p>缓存雪崩是指 在某一时间段，缓存中大量 key 集中过期，或 Redis 集群整体故障，导致大量请求全部穿透到数据库，引发数据库崩溃。</p><p>比对总结</p><table tabindex="0"><thead><tr><th><em><strong>*问题类型*</strong></em></th><th><em><strong>*核心区别（触发条件）*</strong></em></th><th><em><strong>*影响范围*</strong></em></th><th><em><strong>*核心解决方案思路*</strong></em></th></tr></thead><tbody><tr><td>缓存穿透</td><td>请求的 key 在缓存和数据库中均不存在。</td><td>针对无效 key 的请求</td><td>过滤无效 key（布隆过滤器）、缓存空值。</td></tr><tr><td>缓存击穿</td><td>热点 key 过期瞬间，大量并发请求访问。</td><td>单个热点 key</td><td>互斥锁、热点 key 永不过期。</td></tr><tr><td>缓存雪崩</td><td>大量 key 集中过期或 Redis 集群故障。</td><td>大量 key 或整体缓存</td><td>过期时间随机化、Redis 高可用、限流</td></tr></tbody></table>',19)])])}const k=t(i,[["render",o]]);export{p as __pageData,k as default};
